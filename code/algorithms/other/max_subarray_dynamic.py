import random

# Динамическое программирование - это метод решения задач, в котором решение задачи разбивается на подзадачи,
# которые решаются последовательно. В результате решения подзадачи сохраняются в памяти, и при решении
# следующей подзадачи используются результаты предыдущих подзадач. Динамическое программирование
# часто используется для решения задач, которые имеют много общих подзадач, которые решаются
# последовательно. 

# Например, рассмотрим задачу нахождения максимального подмассива в массиве.
# Для этого мы будем искать максимальный подмассив, который заканчивается в текущем элементе.
# Тогда максимальный подмассив, который заканчивается в i-ом элементе, это максимальный подмассив,
# который заканчивается в i-1-ом элементе, плюс i-ый элемент, или же i-ый элемент.
# Тогда максимальный подмассив, который заканчивается в i-ом элементе, это максимум из двух вариантов:
# 1) максимальный подмассив, который заканчивается в i-1-ом элементе, плюс i-ый элемент
# 2) i-ый элемент
# Таким образом, мы можем найти максимальный подмассив, который заканчивается в i-ом элементе за O(1) времени.
# Тогда для нахождения максимального подмассива в массиве, нам нужно пройтись по массиву и для каждого элемента
# найти максимальный подмассив, который заканчивается в этом элементе. Это можно сделать за O(n) времени.
# Тогда общее время работы алгоритма будет O(n).
# Также, чтобы восстановить максимальный подмассив, нам нужно хранить индексы начала и конца максимального подмассива.
# Это можно сделать за O(n) дополнительной памяти.

def max_subarray(array):
    max_sum = array[0]
    max_start = 0
    max_end = 0
    current_sum = array[0]
    current_start = 0
    current_end = 0
    for i in range(1, len(array)):
        if current_sum + array[i] > array[i]:
            current_sum += array[i]
            current_end = i
        else:
            current_sum = array[i]
            current_start = i
            current_end = i
        if current_sum > max_sum:
            max_sum = current_sum
            max_start = current_start
            max_end = current_end
    return max_sum, max_start, max_end

# Или, вот другой, более простой пример: нахождение чисел Фибоначчи.
# Для этого мы будем хранить значения чисел Фибоначчи для всех чисел от 1 до n.
# Тогда для нахождения числа Фибоначчи для n-го числа, нам нужно сложить значения чисел Фибоначчи для n-1-го и n-2-го чисел.
# Таким образом, мы можем найти число Фибоначчи для n-го числа за O(1) времени.
# Тогда для нахождения числа Фибоначчи для n-го числа, нам нужно пройтись по числам от 1 до n и для каждого числа
# найти число Фибоначчи. Это можно сделать за O(n) времени. 
# Тогда общее время работы алгоритма будет O(n).
# Также, чтобы восстановить числа Фибоначчи, нам нужно хранить значения чисел Фибоначчи для всех чисел от 1 до n.
# Это можно сделать за O(n) дополнительной памяти.

def fibonacci_dynamic(n):
    fib = [0, 1]
    for i in range(2, n + 1):
        fib.append(fib[i - 1] + fib[i - 2])
    return fib[n]


if __name__ == '__main__':
    array = random.sample(range(-50, 50), 15)
    print(f'Массив: {array}\n'
          f'Максимальная сумма подмассива: {max_subarray(array)}\n'
          f'Подмассив: {array[max_subarray(array)[1]:max_subarray(array)[2] + 1]}')
    
    n = random.randint(1, 10)
    print(f'Число Фибоначчи для {n}: {fibonacci_dynamic(n)}')
